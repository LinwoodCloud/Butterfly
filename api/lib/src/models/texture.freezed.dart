// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'texture.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

SurfaceTexture _$SurfaceTextureFromJson(Map<String, dynamic> json) {
  return PatternTexture.fromJson(json);
}

/// @nodoc
mixin _$SurfaceTexture {
  double get boxWidth => throw _privateConstructorUsedError;
  double get boxHeight => throw _privateConstructorUsedError;
  int get boxXCount => throw _privateConstructorUsedError;
  int get boxYCount => throw _privateConstructorUsedError;
  double get boxXSpace => throw _privateConstructorUsedError;
  double get boxYSpace => throw _privateConstructorUsedError;
  int get boxXColor => throw _privateConstructorUsedError;
  int get boxYColor => throw _privateConstructorUsedError;
  int get boxColor => throw _privateConstructorUsedError;
  double get boxXStroke => throw _privateConstructorUsedError;
  double get boxYStroke => throw _privateConstructorUsedError;

  /// Serializes this SurfaceTexture to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of SurfaceTexture
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $SurfaceTextureCopyWith<SurfaceTexture> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SurfaceTextureCopyWith<$Res> {
  factory $SurfaceTextureCopyWith(
          SurfaceTexture value, $Res Function(SurfaceTexture) then) =
      _$SurfaceTextureCopyWithImpl<$Res, SurfaceTexture>;
  @useResult
  $Res call(
      {double boxWidth,
      double boxHeight,
      int boxXCount,
      int boxYCount,
      double boxXSpace,
      double boxYSpace,
      int boxXColor,
      int boxYColor,
      int boxColor,
      double boxXStroke,
      double boxYStroke});
}

/// @nodoc
class _$SurfaceTextureCopyWithImpl<$Res, $Val extends SurfaceTexture>
    implements $SurfaceTextureCopyWith<$Res> {
  _$SurfaceTextureCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of SurfaceTexture
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? boxWidth = null,
    Object? boxHeight = null,
    Object? boxXCount = null,
    Object? boxYCount = null,
    Object? boxXSpace = null,
    Object? boxYSpace = null,
    Object? boxXColor = null,
    Object? boxYColor = null,
    Object? boxColor = null,
    Object? boxXStroke = null,
    Object? boxYStroke = null,
  }) {
    return _then(_value.copyWith(
      boxWidth: null == boxWidth
          ? _value.boxWidth
          : boxWidth // ignore: cast_nullable_to_non_nullable
              as double,
      boxHeight: null == boxHeight
          ? _value.boxHeight
          : boxHeight // ignore: cast_nullable_to_non_nullable
              as double,
      boxXCount: null == boxXCount
          ? _value.boxXCount
          : boxXCount // ignore: cast_nullable_to_non_nullable
              as int,
      boxYCount: null == boxYCount
          ? _value.boxYCount
          : boxYCount // ignore: cast_nullable_to_non_nullable
              as int,
      boxXSpace: null == boxXSpace
          ? _value.boxXSpace
          : boxXSpace // ignore: cast_nullable_to_non_nullable
              as double,
      boxYSpace: null == boxYSpace
          ? _value.boxYSpace
          : boxYSpace // ignore: cast_nullable_to_non_nullable
              as double,
      boxXColor: null == boxXColor
          ? _value.boxXColor
          : boxXColor // ignore: cast_nullable_to_non_nullable
              as int,
      boxYColor: null == boxYColor
          ? _value.boxYColor
          : boxYColor // ignore: cast_nullable_to_non_nullable
              as int,
      boxColor: null == boxColor
          ? _value.boxColor
          : boxColor // ignore: cast_nullable_to_non_nullable
              as int,
      boxXStroke: null == boxXStroke
          ? _value.boxXStroke
          : boxXStroke // ignore: cast_nullable_to_non_nullable
              as double,
      boxYStroke: null == boxYStroke
          ? _value.boxYStroke
          : boxYStroke // ignore: cast_nullable_to_non_nullable
              as double,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$PatternTextureImplCopyWith<$Res>
    implements $SurfaceTextureCopyWith<$Res> {
  factory _$$PatternTextureImplCopyWith(_$PatternTextureImpl value,
          $Res Function(_$PatternTextureImpl) then) =
      __$$PatternTextureImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {double boxWidth,
      double boxHeight,
      int boxXCount,
      int boxYCount,
      double boxXSpace,
      double boxYSpace,
      int boxXColor,
      int boxYColor,
      int boxColor,
      double boxXStroke,
      double boxYStroke});
}

/// @nodoc
class __$$PatternTextureImplCopyWithImpl<$Res>
    extends _$SurfaceTextureCopyWithImpl<$Res, _$PatternTextureImpl>
    implements _$$PatternTextureImplCopyWith<$Res> {
  __$$PatternTextureImplCopyWithImpl(
      _$PatternTextureImpl _value, $Res Function(_$PatternTextureImpl) _then)
      : super(_value, _then);

  /// Create a copy of SurfaceTexture
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? boxWidth = null,
    Object? boxHeight = null,
    Object? boxXCount = null,
    Object? boxYCount = null,
    Object? boxXSpace = null,
    Object? boxYSpace = null,
    Object? boxXColor = null,
    Object? boxYColor = null,
    Object? boxColor = null,
    Object? boxXStroke = null,
    Object? boxYStroke = null,
  }) {
    return _then(_$PatternTextureImpl(
      boxWidth: null == boxWidth
          ? _value.boxWidth
          : boxWidth // ignore: cast_nullable_to_non_nullable
              as double,
      boxHeight: null == boxHeight
          ? _value.boxHeight
          : boxHeight // ignore: cast_nullable_to_non_nullable
              as double,
      boxXCount: null == boxXCount
          ? _value.boxXCount
          : boxXCount // ignore: cast_nullable_to_non_nullable
              as int,
      boxYCount: null == boxYCount
          ? _value.boxYCount
          : boxYCount // ignore: cast_nullable_to_non_nullable
              as int,
      boxXSpace: null == boxXSpace
          ? _value.boxXSpace
          : boxXSpace // ignore: cast_nullable_to_non_nullable
              as double,
      boxYSpace: null == boxYSpace
          ? _value.boxYSpace
          : boxYSpace // ignore: cast_nullable_to_non_nullable
              as double,
      boxXColor: null == boxXColor
          ? _value.boxXColor
          : boxXColor // ignore: cast_nullable_to_non_nullable
              as int,
      boxYColor: null == boxYColor
          ? _value.boxYColor
          : boxYColor // ignore: cast_nullable_to_non_nullable
              as int,
      boxColor: null == boxColor
          ? _value.boxColor
          : boxColor // ignore: cast_nullable_to_non_nullable
              as int,
      boxXStroke: null == boxXStroke
          ? _value.boxXStroke
          : boxXStroke // ignore: cast_nullable_to_non_nullable
              as double,
      boxYStroke: null == boxYStroke
          ? _value.boxYStroke
          : boxYStroke // ignore: cast_nullable_to_non_nullable
              as double,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$PatternTextureImpl implements PatternTexture {
  const _$PatternTextureImpl(
      {this.boxWidth = 0,
      this.boxHeight = 0,
      this.boxXCount = 1,
      this.boxYCount = 1,
      this.boxXSpace = 0,
      this.boxYSpace = 0,
      this.boxXColor = BasicColors.blue,
      this.boxYColor = BasicColors.red,
      this.boxColor = BasicColors.white,
      this.boxXStroke = 0.5,
      this.boxYStroke = 0.5});

  factory _$PatternTextureImpl.fromJson(Map<String, dynamic> json) =>
      _$$PatternTextureImplFromJson(json);

  @override
  @JsonKey()
  final double boxWidth;
  @override
  @JsonKey()
  final double boxHeight;
  @override
  @JsonKey()
  final int boxXCount;
  @override
  @JsonKey()
  final int boxYCount;
  @override
  @JsonKey()
  final double boxXSpace;
  @override
  @JsonKey()
  final double boxYSpace;
  @override
  @JsonKey()
  final int boxXColor;
  @override
  @JsonKey()
  final int boxYColor;
  @override
  @JsonKey()
  final int boxColor;
  @override
  @JsonKey()
  final double boxXStroke;
  @override
  @JsonKey()
  final double boxYStroke;

  @override
  String toString() {
    return 'SurfaceTexture.pattern(boxWidth: $boxWidth, boxHeight: $boxHeight, boxXCount: $boxXCount, boxYCount: $boxYCount, boxXSpace: $boxXSpace, boxYSpace: $boxYSpace, boxXColor: $boxXColor, boxYColor: $boxYColor, boxColor: $boxColor, boxXStroke: $boxXStroke, boxYStroke: $boxYStroke)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PatternTextureImpl &&
            (identical(other.boxWidth, boxWidth) ||
                other.boxWidth == boxWidth) &&
            (identical(other.boxHeight, boxHeight) ||
                other.boxHeight == boxHeight) &&
            (identical(other.boxXCount, boxXCount) ||
                other.boxXCount == boxXCount) &&
            (identical(other.boxYCount, boxYCount) ||
                other.boxYCount == boxYCount) &&
            (identical(other.boxXSpace, boxXSpace) ||
                other.boxXSpace == boxXSpace) &&
            (identical(other.boxYSpace, boxYSpace) ||
                other.boxYSpace == boxYSpace) &&
            (identical(other.boxXColor, boxXColor) ||
                other.boxXColor == boxXColor) &&
            (identical(other.boxYColor, boxYColor) ||
                other.boxYColor == boxYColor) &&
            (identical(other.boxColor, boxColor) ||
                other.boxColor == boxColor) &&
            (identical(other.boxXStroke, boxXStroke) ||
                other.boxXStroke == boxXStroke) &&
            (identical(other.boxYStroke, boxYStroke) ||
                other.boxYStroke == boxYStroke));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      boxWidth,
      boxHeight,
      boxXCount,
      boxYCount,
      boxXSpace,
      boxYSpace,
      boxXColor,
      boxYColor,
      boxColor,
      boxXStroke,
      boxYStroke);

  /// Create a copy of SurfaceTexture
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$PatternTextureImplCopyWith<_$PatternTextureImpl> get copyWith =>
      __$$PatternTextureImplCopyWithImpl<_$PatternTextureImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$PatternTextureImplToJson(
      this,
    );
  }
}

abstract class PatternTexture implements SurfaceTexture {
  const factory PatternTexture(
      {final double boxWidth,
      final double boxHeight,
      final int boxXCount,
      final int boxYCount,
      final double boxXSpace,
      final double boxYSpace,
      final int boxXColor,
      final int boxYColor,
      final int boxColor,
      final double boxXStroke,
      final double boxYStroke}) = _$PatternTextureImpl;

  factory PatternTexture.fromJson(Map<String, dynamic> json) =
      _$PatternTextureImpl.fromJson;

  @override
  double get boxWidth;
  @override
  double get boxHeight;
  @override
  int get boxXCount;
  @override
  int get boxYCount;
  @override
  double get boxXSpace;
  @override
  double get boxYSpace;
  @override
  int get boxXColor;
  @override
  int get boxYColor;
  @override
  int get boxColor;
  @override
  double get boxXStroke;
  @override
  double get boxYStroke;

  /// Create a copy of SurfaceTexture
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$PatternTextureImplCopyWith<_$PatternTextureImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
